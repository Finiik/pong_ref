# pong_refactored

## ФЕП-31

### Фіняк Олег, Кравець Ігор, Боршош Володимир, Бойко Дмитро

## Оригінал проєкту: Зимова командна практика в компанії GlobalLogic

### Опис проєкту

Ідея проекту нашої команди полягала у створенні аналогу портативного ігрового пристрою, в якому роль екрану буде виконувати програма на Python, а всіма обрахунками (перехід між частинами меню, обрахунок координатів м’ячика та платформи, запис кількості набраних очків) займатись налагоджувана плата.
Проект мав працювати за таким принципом: з Python програми через UART надсилається протокол перевірки на обраний в початковому меню комунікаційний порт і перевіряється чи повертає налагоджувана плата відповідний протокол, в якому зашифрована кількість ігор у відповідь. Якщо так, тоді відкривалось меню вибору ігор, де гравець обирав доступні на STM ігри. Такою грою був Pong, гра, суттю якої є циклічне відбивання м’ячика платформою, коли м’ячик відбивається від стін та повертається до неї. Якщо м’яч залітає поза платформу, то зараховується програш. Коли ми обирали гру, то з STM надсилався відповідний протокол, в якому було зашифровано розмір поля, найкращий результат, та початкові координати об’єктів, якими є платформа та м’яч. Після початку гри, STM постійно надсилає протокол для програми з координатами об’єктів, відповідно до їхнього руху та обраховує кількість очок. Правильність та відповідність протоколів перевірялось за допомогою BCC обрахунку протоколу по байтах.

## Зарефакторений проєкт

### Мета рефакторингу: Зробити проєкт на Python, що виконуватиме всі функції самостійно без протоколів та плати STM, та додати ігри які не встигли бути реалізовані на практиці

### Використані методи рефакторингу

Фіняк Олег:

1. Розділення великих методів на менші
   Місце застосування: Метод run()

2. Використання констант замість магічних чисел
   Місце застосування: Різні місця, де використовуються числові значення без пояснення. (FRAME_RATE = 60
   SCREEN_WIDTH = 320
   SCREEN_HEIGHT = 640
   )

3. Заміна повторюваних блоків коду функціями
   Місце застосування: Виведення тексту в центр екрана.

4. Оптимізація роботи з розмірами прямокутників
   Місце застосування: Обробка колізій між м’ячем і платформою.

5. Використання більш специфічних умов у логіці
   Місце застосування: Обробка колізії з платформою.

6. Поліпшення логіки скидання гри
   Місце застосування: Метод reset_game()

7. Використання списків для зберігання інструкцій
   Місце застосування: Виведення інструкцій на екран.

8. Прибирання невикористовуваних методів
   decode_value(), calculate_bcc()

9. Реінжинірінг коду в функції draw_game(), а саме спрощення коду в цій частині

10. Покращення обробки подій клавіатури
    Місце застосування: Метод handle_input()

11. Покращення обробки подій в меню
    Місце застосування: Метод show_menu()

Боршош Володимир:

1. Винесення констант: У другому коді визначено багато констант на початку файлу
   (наприклад, WIDTH, HEIGHT, SNAKE_COLOR, GAME_SPEED тощо). Це робить код більш читабельним
   та полегшує зміну параметрів гри. У першому коді розміри вікна та колір змійки були "зашиті" безпосередньо в коді.

2. Організація коду в клас Game: Другий код використовує об'єктно-орієнтований підхід,
   об'єднуючи дані та функціональність гри в клас Game. Це покращує структуру коду,
   робить його більш модульним та полегшує керування станом гри. Перший код був написаний у процедурному стилі.

3. Розділення ігрової логіки та відображення: У класі Game чітко розділені методи,
   що відповідають за оновлення стану гри (update_snake), обробку вводу (handle_input),
   малювання ігрових елементів (draw_game) та обробку подій (handle_events).
   Це робить код більш зрозумілим і підтримуваним.

4. Використання окремої ігрової поверхні: Другий код створює окрему поверхню (game_surface)
   для малювання ігрового поля та його елементів, а потім накладає її на головний екран.
   Це полегшує керування шарами відображення та додавання UI елементів навколо ігрового поля.

5. Покращений UI: Другий код додає інформативний користувацький інтерфейс (UI),
   який відображає поточний та найкращий рахунок, а також інструкції з керування грою.
   Він також показує повідомлення "Game Over" та "Paused". Перший код відображав лише ігрове поле.

6. Пауза в грі: Реалізовано функціональність паузи гри за натисканням клавіші 'P'. Це покращує зручність користувача.

7. Рестарт гри: Додано можливість перезапуску гри за натисканням клавіші 'R'.

8. Центрування та форматування тексту: У другому коді використовуються допоміжні методи (blit_text_centered, blit_text_left)
    для зручного відображення тексту з вирівнюванням та заданим шрифтом. Це покращує візуальне представлення тексту.

9. Відображення меж ігрового поля: Другий код малює рамку навколо ігрового поля,
    що візуально відокремлює ігрову зону від іншої частини екрана.

10. Інтеграція з базою даних: Другий код містить посилання на класи Models.User та db_config,
    що свідчить про зберігання найкращого рахунку користувача в базі даних. Це додає функціональність збереження прогресу гравця.

## Тести

### Запуск тестування: $env:PYTHONPATH="."; pytest Tests/

\*\* В папці new

## Підсумки та висновки

### Підвишення продуктивності

- Обробка процесів йде напряму програмою, а не зовнішніми пристроями, що підвищує швидкість
- Прибирання протоколів передачі та зовнішніх пристроїв зменшує кількість перевірок даних та кількість точок, де дані можуть передаватись некоректно

### Метрики коду

- Покращена читабельність, кількість коментарів
- Чіткі назви змінних та функцій

### Візуальне порівняння

- Візуально код виглядає чіткіше, чистіше і легше сприймається на око. В оригіналі багато методів були одинаково названі, написані абияк, що дуже сильно ускладнювало дебагінг проєкту
